@main {
    @block {
        @image(uri: "/img/c.png") {}
        @paragraph {
            @bold {Си} (англ. @bold {C}) — компилируемый статически типизированный
            @link(uri: "/index.oml") { язык программирования } общего назначения, разработанный
            в 1969—1973 годах сотрудником
            Bell Labs Деннисом Ритчи как развитие языка Би. Первоначально был разработан для
            реализации операционной системы UNIX, но впоследствии был перенесён на множество
            других платформ. Согласно дизайну языка, его конструкции близко сопоставляются
            типичным машинным инструкциям, благодаря чему он нашёл применение в проектах, для
            которых был свойственен язык ассемблера, в том числе как в операционных системах,
            так и в различном прикладном программном обеспечении для множества устройств — от
            суперкомпьютеров до встраиваемых систем. Язык программирования Си оказал существенное
            влияние на развитие индустрии программного обеспечения, а его синтаксис стал основой
            для таких языков программирования, как @link(uri: "/langs/cpp.oml") { C++ }, C#,
            @link(uri: "/langs/java.oml") { Java } и Objective-C.
        }
    }

    @block {
        @heading(level: "2") {
            История
        }
        @paragraph {
            Язык программирования Си разрабатывался в период с 1969 по 1973 годы в лабораториях
            Bell Labs, и к 1973 году на него была переписана большая часть ядра UNIX,
            первоначально написанного на ассемблере PDP-11/20. Название языка стало логическим
            продолжением старого языка «Би», многие особенности которого были положены в основу.
        }
        @paragraph {
            По мере развития язык сначала стандартизировали как ANSI C, а затем этот стандарт
            был принят комитетом по международной стандартизации ISO как ISO C, ставший также
            известным под названием C90. В стандарте С99 язык получил новые возможности, из
            которых в качестве наиболее значимых можно отметить массивы переменной длины и
            встраиваемые функции. А в стандарте C11 в язык добавили реализацию потоков и
            поддержку атомарных типов. Однако с тех пор язык развивается медленно, и в стандарт
            С18 попали лишь исправления ошибок стандарта C11.
        }
    }

    @block {
        @heading(level: "2") {
            Общие сведения
        }
        @paragraph {
            Язык Си разрабатывался как язык системного программирования, для которого можно
            создать однопроходный компилятор. Стандартная библиотека также невелика. Как
            следствие данных факторов — компиляторы разрабатываются сравнительно легко. Поэтому
            данный язык доступен на самых различных платформах. К тому же, несмотря на свою
            низкоуровневую природу, язык ориентирован на переносимость. Программы, соответствующие
            стандарту языка, могут компилироваться под различные архитектуры компьютеров.
        }
        @paragraph {
            Целью языка было облегчение написания больших программ с минимизацией ошибок по
            сравнению с ассемблером, следуя принципам процедурного программирования, но избегая
            всего, что может привести к дополнительным накладным расходам, специфичным для языков
            высокого уровня.
        }

        @columns {
            @block {
                @heading(level: "5") {
                    Основные особенности Си:
                }
                @list {
                    @paragraph {
                        простая языковая база, из которой в стандартную библиотеку вынесены многие
                        существенные возможности, вроде математических функций или функций работы
                        с файлами;
                    }
                    @paragraph {
                        ориентация на процедурное программирование;
                    }
                    @paragraph {
                        система типов, предохраняющая от бессмысленных операций;
                    }
                    @paragraph {
                        использование препроцессора для абстрагирования однотипных операций;
                    }
                    @paragraph {
                        доступ к памяти через использование указателей;
                    }
                    @paragraph {
                        небольшое число ключевых слов;
                    }
                    @paragraph {
                        передача параметров в функцию по значению, а не по ссылке (передача по ссылке
                        эмулируется с помощью указателей);
                    }
                    @paragraph {
                        наличие указателей на функции и статических переменных;
                    }
                    @paragraph {
                        области видимости имён;
                    }
                    @paragraph {
                        структуры и объединения — определяемые пользователем собирательные типы данных, которыми можно манипулировать как одним целым.
                    }
                }
            }
            @block {
                @heading (level: "5"){
                    В то же время в Си отсутствуют:
                }
                @list {
                    @paragraph {
                        вложенные функции;
                    }
                    @paragraph {
                        сопрограммы;
                    }
                    @paragraph {
                        средства автоматического управления памятью;
                    }
                    @paragraph {
                        встроенные средства объектно-ориентированного программирования;
                    }
                    @paragraph {
                        средства функционального программирования.
                    }
                }
            }
        }
        @paragraph {
            Часть отсутствующих возможностей может имитироваться встроенными средствами
            (например, сопрограммы можно имитировать с помощью функций setjmp и longjmp),
            часть добавляется с помощью сторонних библиотек (например, для поддержки
            многозадачности и для сетевых функций можно использовать библиотеки pthreads,
            sockets и тому подобные; существуют библиотеки для поддержки автоматической
            сборки мусора), часть реализуется в некоторых компиляторах в виде расширений
            языка (например, вложенные функции в GCC). Существует несколько громоздкая,
            но вполне работоспособная методика, позволяющая реализовывать на Си механизмы
            ООП, базирующаяся на фактической полиморфности указателей в Си и поддержке
            в этом языке указателей на функции. Механизмы ООП, основанные на данной модели,
            реализованы в библиотеке GLib и активно используются в фреймворке GTK+. GLib
            предоставляет базовый класс GObject, возможности наследования от одного класса
            и реализации множества интерфейсов.
        }
        @paragraph{
            После появления язык был хорошо принят, потому что он позволял быстро создавать
            компиляторы для новых платформ, а также позволял программистам довольно точно
            представлять, как выполняются их программы. Благодаря близости к языкам низкого
            уровня программы на Си работали эффективнее написанных на многих других языках
            высокого уровня, и лишь оптимизированный вручную код на ассемблере мог работать ещё
            быстрее, потому что давал полный контроль над машиной. На сегодняшний день развитие
            компиляторов и усложнение процессоров привело к тому, что вручную написанный
            ассемблерный код (кроме разве что очень коротких программ) практически не выигрывает
            по сравнению с кодом, генерируемым компиляторами, при этом Си продолжает оставаться
            одним из наиболее эффективных языков высокого уровня.
        }
    }
}
